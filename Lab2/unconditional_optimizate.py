import numpy as npimport math as Mathclass FuncAnalytics:    def __init__(self, a, b, eps, N, func, dfunc):        self.N = N        self.eps = eps        self.a = a        self.b = b        self.func = func        self.dfunc = dfunc    def get_func_value(self):        ax = self.a        bx = self.b        dx = 0.5        _x = []        _y = []        x = ax        while x < bx:            _y.append(self.func(x))            _x.append(x)            x += dx        return _x, _y    def passive_algorithm(self):        x, y, k = [], [], 0        a, b, N = self.a, self.b, self.N        delta = (b - a) / N        if N % 2 == 0:            k = N / 2        else:            k = (N - 1) / 2        def get_func_values(ax, bx):            _x, _y = [], []            for i in range(N):                if N % 2 == 0:                    _x.append(ax + (bx - ax) / (N + 1) * i)                else:                    tmp = ax + (bx - ax) / (k + 1) * i                    _x.append(tmp - delta)                    _x.append(tmp)            for i in _x:                _y.append(self.func(i))            return _x, _y        LN = 0        if N % 2 == 0:            LN = 2 * (b - a) / (N + 1)        else:            LN = 2 * (b - a) / (k + 1) + delta        eps = LN / 2        x, y = get_func_values(a, b)        min_y = np.min(y)        j = y.index(min_y)        L = x[j + 1] - x[j - 1]  #длина нового отрезка локализации        exact_min_y, exact_min_x = 0, 0        tmp_x, tmp_y = x, y        while np.fabs(exact_min_y - min_y) > eps:            tmp_x, tmp_y = get_func_values(tmp_x[j - 1], tmp_y[j + 1])            exact_min_y = np.min(tmp_y)            j = tmp_y.index(exact_min_y)            exact_min_x = tmp_x[j]        return exact_min_x, exact_min_y    def blockSearch(self):        a, b, N = self.a, self.b, self.N        k = (N - 1) / 2        x_k = (a + b) / 2        y_k = self.func(x_k)  #значение функции в середине отрезка локализации        x, y = [], []        def get_func_values(ax, bx):            _x, _y = [], []            for i in range(N):                if i != round(k):                    _x.append(ax + i * (bx - ax) / (N + 1))            for i in _x:                _y.append(self.func(i))            return _x, _y        x, y = get_func_values(a, b)        min_y = np.min(y)        j = y.index(min_y)        exact_a, exact_b = x[j - 1], x[j + 1]        exact_min_x, exact_min_y = 0, 0        tmp_x, tmp_y = [], []        while exact_b - exact_a >= 2 * self.eps:            tmp_x, tmp_y = get_func_values(exact_a, exact_b)            exact_min_y = np.min(tmp_y)            j = tmp_y.index(exact_min_y)            exact_min_x = tmp_x[j]            exact_a, exact_b = tmp_x[j - 1], tmp_x[j + 1]        return exact_min_x, exact_min_y    def goldenRationMethod(self):        a, b, N = self.a, self.b, self.N        delta = 1.618        x_1 = b - (b - a) / delta        x_2 = a + (b - a) / delta        y_1 = self.func(x_1)        y_2 = self.func(x_2)        exact_x, exact_y = 0, 0        while b - a > self.eps:            if y_1 <= y_2:                b = x_2                x_2 = x_1                y_2 = y_1                x_1 = a + b - x_2                y_1 = self.func(x_1)            else:                a = x_1                x_1 = x_2                y_1 = y_2                x_2 = a + b - x_1                y_2 = self.func(x_2)        if y_1 < y_2:            exact_x = x_1            exact_y = y_1        else:            exact_x = x_2            exact_y = y_2        return exact_x, exact_y    def fibonacciMethod(self):        a, b, N = self.a, self.b, self.N        def _get_number_fibonacci(n):            F = [1, 1]            for i in range(2, n):                F.append(F[i - 1] + F[i - 2])            return F        F = _get_number_fibonacci(N)        x1 = a + (b - a) * (F[N - 2] / F[N - 1])        x2 = a + (b - a) * (F[N - 1] / F[N - 1])        y1, y2 = self.func(x1), self.func(x2)        for i in range(N - 2):            if y1 <= y2:                b, x2, y2 = x2, x1, y1                x1 = a + b - x2                y1 = self.func(x1)            else:                a, x1, y1 = x1, x2, y2                x2 = a + b - x1                y2 = self.func(x2)        if y1 < y2:            return x1, y1        else:            return x2, y2    def cubicInterpolationMethod(self, x_1):        z, w, gamma = 0, 0, 0        a, b, N = self.a, self.b, self.N        approximating_min = x_1        def calcZ():            return self.dfunc(a) + self.dfunc(b) + 3 * ((self.func(b) - self.func(a)) / (b - a))        def calcW():            return np.sqrt(Math.pow(z, 2) - self.dfunc(a) * self.dfunc(b))        def calcGamma():            return (z + w - self.dfunc(a)) / (self.dfunc(b) - self.dfunc(a) + 2 * w)        def step_1():            if 0 <= gamma <= 1:                return a + gamma * (b - a)            elif gamma < 0:                return a            else:                return b        z = calcZ()        w = calcW()        gamma = calcGamma()        approximating_min = step_1()       #аппроксимирующий минимум        while np.fabs(self.dfunc(approximating_min) > self.eps) or np.around(approximating_min, 2) != np.around(a, 2)\                or np.around(approximating_min, 2) != np.around(b, 2):            if self.dfunc(approximating_min) > 0:                b = approximating_min                z = calcZ()                w = calcW()                gamma = calcGamma()                approximating_min = step_1()            else:                a = approximating_min                z = calcZ()                w = calcW()                gamma = calcGamma()                approximating_min = step_1()        y_min = self.func(approximating_min)        return approximating_min, y_min